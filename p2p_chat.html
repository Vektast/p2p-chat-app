<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modern P2P Chat & File Sharing</title>
    <style>
        /* Base styles and modernization */
        :root {
            --primary-color: #007bff;
            --secondary-color: #6c757d;
            --success-color: #28a745;
            --danger-color: #dc3545;
            --warning-color: #ffc107;
            /* More yellowish, better text visibility */
            --info-color: #17a2b8;
            --light-color: #f8f9fa;
            --dark-color: #343a40;
            --background-color: #f0f2f5;
            --text-color: #212529;
            --muted-text-color: #6c757d;
            --border-color: #dee2e6;
            --border-radius: 0.375rem;
            --box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.1);
            --box-shadow-sm: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
        }

        .container {
            max-width: 900px;
            margin: 20px auto;
            background-color: #fff;
            padding: 20px;
            /* A bit less, sections will have their own padding */
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
        }

        h1 {
            font-size: 2em;
            text-align: center;
            margin-bottom: 1.2em;
            color: var(--primary-color);
        }

        h2 {
            font-size: 1.5em;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.3em;
            margin-bottom: 0.75em;
            color: var(--primary-color);
        }

        .section {
            margin-bottom: 25px;
            padding: 20px;
            background-color: #fff;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow-sm);
        }

        .app-info p {
            margin-bottom: 0.5em;
        }

        .app-info code {
            background-color: #e9ecef;
            padding: 0.2em 0.4em;
            border-radius: 0.2rem;
            font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }

        #myName {
            font-weight: bold;
            color: var(--success-color);
        }

        #myPeerId {
            font-size: 0.9em;
            color: var(--muted-text-color);
        }

        .peer-list #peersContainer ul {
            list-style: none;
            padding: 0;
        }

        .peer-list #peersContainer p {
            /* For "No peers available" message */
            color: var(--muted-text-color);
            font-style: italic;
        }

        .peer {
            background-color: var(--light-color);
            padding: 12px 15px;
            margin-bottom: 8px;
            border-radius: var(--border-radius);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid var(--border-color);
            transition: background-color 0.2s ease;
        }

        .peer:hover {
            background-color: #e9ecef;
        }

        .peer span {
            flex-grow: 1;
            font-weight: 500;
        }

        .peer button {
            background-color: var(--info-color);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: var(--border-radius);
            cursor: pointer;
            margin-left: 10px;
            font-size: 0.9em;
            transition: background-color 0.2s ease;
        }

        .peer button:hover {
            background-color: #138496;
        }

        /* Message styles */
        .chat-log {
            max-height: 450px;
            overflow-y: auto;
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background-color: #fdfdfd;
            margin-bottom: 20px;
            /* Space before input area */
        }

        .message {
            padding: 10px 15px;
            margin-bottom: 10px;
            border-radius: var(--border-radius);
            position: relative;
            transition: opacity 0.5s ease-out;
            box-shadow: var(--box-shadow-sm);
            line-height: 1.4;
            max-width: 80%;
            /* Default max width */
        }

        .message.fade-out {
            opacity: 0;
        }

        .message .sender {
            font-weight: bold;
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .message .content {
            word-wrap: break-word;
        }

        .message .content a {
            color: var(--primary-color);
            text-decoration: underline;
            font-weight: 500;
        }

        .message .content a:hover {
            text-decoration: none;
        }

        .message .content strong {
            /* Filename highlight */
            color: var(--dark-color);
        }


        .message .progress-bar-container {
            width: 100%;
            background-color: #e9ecef;
            border-radius: var(--border-radius);
            margin-top: 8px;
            height: 22px;
            /* Increased height */
            overflow: hidden;
            /* Important for inner bar radius */
        }

        .message .progress-bar {
            width: 0%;
            height: 100%;
            background-color: var(--success-color);
            border-radius: var(--border-radius);
            /* Maybe only left side is needed if container has radius too */
            text-align: center;
            line-height: 22px;
            color: white;
            font-size: 0.85em;
            font-weight: bold;
            transition: width 0.15s ease-out;
            overflow: hidden;
            white-space: nowrap;
        }

        .message .actions button {
            /* File accept/reject buttons */
            margin-left: 5px;
            margin-top: 8px;
            padding: 5px 10px;
            font-size: 0.9em;
            border-radius: var(--border-radius);
            cursor: pointer;
            border: 1px solid transparent;
        }

        .message .actions button:first-child {
            margin-left: 0;
        }

        .message .actions button:nth-child(1) {
            background-color: var(--success-color);
            color: white;
        }

        .message .actions button:nth-child(1):hover {
            background-color: #1e7e34;
        }

        .message .actions button:nth-child(2) {
            background-color: var(--danger-color);
            color: white;
        }

        .message .actions button:nth-child(2):hover {
            background-color: #c82333;
        }


        .message .copy-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            font-size: 0.75em;
            padding: 3px 6px;
            background-color: var(--secondary-color);
            color: white;
            border: none;
            border-radius: 0.25rem;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .message:hover .copy-btn {
            opacity: 0.7;
        }

        .message .copy-btn:hover {
            opacity: 1;
        }

        .my-message {
            background-color: #cfe2ff;
            /* Lighter, more saturated blue */
            margin-left: auto;
            border-bottom-right-radius: 0;
        }

        .my-message .sender {
            color: #052c65;
        }

        /* Darker blue for contrast */

        .their-message {
            background-color: #e9ecef;
            /* Slightly darker gray */
            margin-right: auto;
            border-bottom-left-radius: 0;
        }

        .their-message .sender {
            color: #343a40;
        }

        .system-message {
            background-color: var(--warning-color);
            color: #4d3800;
            /* Darker yellow text */
            border: 1px solid #ffb000;
            text-align: center;
            font-size: 0.9em;
            padding: 8px;
            max-width: 100%;
            /* Full width */
            border-radius: var(--border-radius);
            /* Uniform */
        }

        .file-transfer-message {
            border-left: 4px solid var(--info-color);
        }

        .file-transfer-message .content .status-text {
            /* Done, Error etc. */
            font-style: italic;
            font-size: 0.9em;
            color: var(--muted-text-color);
            margin-left: 5px;
        }


        /* Input area */
        .input-area {
            display: flex;
            gap: 10px;
            align-items: stretch;
            /* Buttons and input should have the same height */
        }

        #messageInput {
            flex-grow: 1;
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 1em;
        }

        #messageInput:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, .25);
        }

        #recipientSelect {
            padding: 10px;
            /* Smaller if only IDs */
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background-color: white;
            font-size: 1em;
            min-width: 150px;
            /* Minimum width so it's not too small */
        }

        #sendButton,
        #sendBroadcastButton {
            padding: 10px 18px;
            background-color: var(--success-color);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 1em;
            font-weight: 500;
            white-space: nowrap;
            /* Don't break button text */
            transition: background-color 0.2s ease;
        }

        #sendButton:hover,
        #sendBroadcastButton:hover {
            background-color: #1e7e34;
        }

        #sendButton.hidden,
        #recipientSelect.hidden {
            display: none;
        }

        /* Responsiveness for input area */
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            h1 {
                font-size: 1.8em;
            }

            h2 {
                font-size: 1.3em;
            }

            .section {
                padding: 15px;
            }

            .chat-log {
                max-height: 350px;
            }

            .message {
                max-width: 90%;
            }

            .input-area {
                flex-direction: column;
                align-items: stretch;
            }

            #messageInput,
            #recipientSelect,
            #sendButton,
            #sendBroadcastButton {
                width: 100%;
                margin-bottom: 10px;
            }

            #recipientSelect+#messageInput {
                /* If select is visible, add space below it */
                margin-top: 0;
                /* But if select is hidden, don't add unnecessary space */
            }

            #sendButton,
            #sendBroadcastButton {
                margin-bottom: 0;
                /* Last element doesn't need bottom margin in the group */
            }

            #sendButton:not(.hidden) {
                /* If sendButton is visible */
                margin-bottom: 10px;
                /* Then add space before broadcast button */
            }
        }

        /* Toggle switch styles */
        .auto-accept-files {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }

        .auto-accept-files span {
            margin-left: 10px;
            font-size: 0.9em;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.toggle-slider {
            background-color: var(--success-color);
        }

        input:focus+.toggle-slider {
            box-shadow: 0 0 1px var(--success-color);
        }

        input:checked+.toggle-slider:before {
            transform: translateX(26px);
        }

        @media (max-width: 480px) {
            .peer {
                flex-direction: column;
                align-items: flex-start;
            }

            .peer div {
                display: flex;
                width: 100%;
                gap: 8px;
                margin-top: 8px;
            }

            .peer button {
                margin-left: 0;
                flex: 1;
            }

            h1 {
                font-size: 1.6em;
            }

            h2 {
                font-size: 1.2em;
            }

            .auto-accept-files {
                margin-top: 15px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Modern P2P Chat & File Sharing</h1>

        <div class="app-info section">
            <p>Your name: <span id="myName">Generating...</span> (<span id="myPeerId"></span>)</p>
            <p>Signaling server: <code id="signalingServerAddress">ws://192.168.0.251:8080</code></p>
            <p style="font-size:0.9em; color: var(--muted-text-color);">Messages and files are transmitted directly
                between peers (P2P) after the connection is established.</p>
            <div class="auto-accept-files">
                <label class="toggle-switch">
                    <input type="checkbox" id="autoAcceptFiles" checked>
                    <span class="toggle-slider"></span>
                </label>
                <span>Auto-accept files</span>
            </div>
        </div>

        <div class="peer-list section">
            <h2>Available Peers:</h2>
            <div id="peersContainer">
                <p>No peers available at the moment.</p>
            </div>
        </div>

        <div class="chat-container section">
            <h2>Chat and File Transfer:</h2>
            <div id="messages" class="chat-log"></div>
            <div class="input-area">
                <select id="recipientSelect" class="hidden"></select>
                <input type="text" id="messageInput" placeholder="Message...">
                <button id="sendButton" class="hidden">Send to Selected</button>
                <button id="sendBroadcastButton">Send to Everyone</button>
            </div>
        </div>
    </div>

    <script>
        const myNameSpan = document.getElementById('myName');
        const myPeerIdSpan = document.getElementById('myPeerId');
        const peersContainer = document.getElementById('peersContainer');
        const messagesDiv = document.getElementById('messages');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const sendBroadcastButton = document.getElementById('sendBroadcastButton');
        const recipientSelect = document.getElementById('recipientSelect');
        const signalingServerAddressSpan = document.getElementById('signalingServerAddress');
        const autoAcceptFilesToggle = document.getElementById('autoAcceptFiles');

        // Load saved auto-accept preference from localStorage
        if (localStorage.getItem('autoAcceptFiles') === 'false') {
            autoAcceptFilesToggle.checked = false;
        }

        // Save auto-accept preference when changed
        autoAcceptFilesToggle.addEventListener('change', function () {
            localStorage.setItem('autoAcceptFiles', this.checked);
            console.log(`Auto-accept files: ${this.checked ? 'enabled' : 'disabled'}`);
        });

        let myRandomName = generateRandomName();
        myNameSpan.textContent = myRandomName;
        let localPeerId = null;

        // Automatically use the same host and port as the current page
        const SIGNALING_SERVER_URL = `ws://${window.location.host}`;
        signalingServerAddressSpan.textContent = SIGNALING_SERVER_URL;

        let peerConnections = {};
        let dataChannels = {};
        let peerNames = {};

        const CHUNK_SIZE = 64 * 1024;
        const MAX_BUFFERED_AMOUNT_SEND_THRESHOLD = 8 * 1024 * 1024;
        let fileTransfers = {};

        // Mobile data channel keep-alive mechanism
        let isFileOperationActive = false;
        let keepAliveIntervals = {}; // Store intervals per peer

        // Mobile-optimized WebRTC configuration with enhanced ICE servers
        const configuration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' } // Reduced to 3 STUN servers for better performance
            ],
            iceCandidatePoolSize: 10, // Increased for mobile compatibility
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require'
        };

        // Mobile device detection
        const isMobileDevice = () => {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                (navigator.maxTouchPoints && navigator.maxTouchPoints > 2);
        };

        // Enhanced logging for mobile peer discovery debugging
        const logPeerDiscovery = (level, message, peerId = null, extra = {}) => {
            const deviceType = isMobileDevice() ? 'MOBILE' : 'DESKTOP';
            const timestamp = new Date().toISOString();
            const peerInfo = peerId ? ` [Peer: ${peerNames[peerId] || peerId}]` : '';
            const extraInfo = Object.keys(extra).length > 0 ? ` ${JSON.stringify(extra)}` : '';

            console.log(`[${timestamp}] [${deviceType}] [PEER-DISCOVERY-${level.toUpperCase()}]${peerInfo} ${message}${extraInfo}`);
        };

        // Connection establishment retry configuration
        const connectionRetryConfig = {
            maxRetries: isMobileDevice() ? 5 : 3,
            baseDelay: 1000,
            maxDelay: 8000,
            backoffMultiplier: 1.5
        };

        // Track connection attempts for retry logic
        let connectionAttempts = {};
        let connectionTimeouts = {};

        const ws = new WebSocket(SIGNALING_SERVER_URL);

        ws.onopen = () => {
            console.log("Connected to signaling server.");
            displayMessage('SYSTEM', `Successfully connected to signaling server (${SIGNALING_SERVER_URL})`, 'system-message');
        };

        ws.onmessage = async (event) => {
            const message = JSON.parse(event.data);
            const remoteId = message.id || message.source;

            switch (message.type) {
                case 'id':
                    localPeerId = message.id;
                    myPeerIdSpan.textContent = `ID: ${localPeerId}`;
                    console.log("Own Peer ID from signaling server:", localPeerId);
                    break;
                case 'discover':
                    if (message.id && message.id !== localPeerId) {
                        logPeerDiscovery('info', 'New peer discovered, initiating connection', message.id, {
                            remoteDeviceType: message.deviceType || 'unknown'
                        });

                        // Initialize peer name as "Connecting..." until we get the actual name
                        if (!peerNames[message.id]) {
                            peerNames[message.id] = `Connecting... (${message.id.substring(0, 6)})`;
                        }

                        // Use enhanced peer discovery for mobile-to-mobile connections
                        enhancedPeerDiscovery(message.id, message.deviceType);

                        // Update the peer list to show the new peer immediately
                        updatePeersList();
                    }
                    break;
                case 'request': // simple-webrtc-p2p-signaling 'request' message
                    if (message.data && message.data.sdp && message.data.sdp.type === 'offer' && message.id !== localPeerId) {
                        const offerSenderName = message.data.name || 'Unknown Peer';
                        const deviceType = message.data.deviceType || 'unknown';
                        const attempt = message.data.attempt || 1;
                        peerNames[message.id] = offerSenderName;
                        logPeerDiscovery('info', `Offer received via request message`, message.id, {
                            senderName: offerSenderName,
                            deviceType: deviceType,
                            attempt: attempt
                        });
                        await handleOffer(message.id, message.data.sdp, offerSenderName, deviceType, attempt);
                    }
                    break;
                default: // SDP (offer/answer) or ICE candidate from a known remoteId
                    if (remoteId && remoteId !== localPeerId) {
                        if (message.sdp && message.sdp.type === 'offer') { // This part is handled by 'request' in simple-webrtc-p2p-signaling
                            const offerSenderName = message.name || (message.data && message.data.name) || 'Unknown Peer';
                            peerNames[remoteId] = offerSenderName;
                            console.log(`Offer received (direct) from ${remoteId} (${offerSenderName}). Sending response.`);
                            await handleOffer(remoteId, message.sdp, offerSenderName);
                        } else if (message.sdp && message.sdp.type === 'answer') {
                            console.log(`Answer received from ${remoteId} (${peerNames[remoteId] || 'unknown'}).`);
                            await handleAnswer(remoteId, message.sdp);
                        } else if (message.candidate) {
                            await handleCandidate(remoteId, message.candidate);
                        } else if (message.type === 'user_left' || message.type === 'disconnect') {
                            console.log(`Peer ${remoteId} (${peerNames[remoteId] || 'unknown'}) left (server notification).`);
                            handleDisconnect(remoteId);
                        }
                    }
                    break;
            }
        };
        ws.onerror = (error) => {
            console.error("Signaling server error:", error);
            displayMessage('SYSTEM', `Error with signaling server connection. Make sure it's running and accessible at ${SIGNALING_SERVER_URL}. Try refreshing the page.`, 'system-message');
        };
        ws.onclose = () => {
            displayMessage('SYSTEM', `Connection to signaling server closed (${SIGNALING_SERVER_URL}). Reconnection is not automatic, please refresh the page.`, 'system-message');
        };

        function generateRandomName() {
            const adjectives = ["Swift", "Lazy", "Smart", "Funny", "Brave", "Quiet", "Fast", "Big", "Small", "Green", "Blue", "Red", "Yellow", "Happy", "Serious"];
            const nouns = ["Fox", "Dog", "Cat", "Bird", "Lion", "Tiger", "Elephant", "Mouse", "Panda", "Koala", "Hedgehog", "Squirrel", "Wolf", "Bear"];
            return `${adjectives[Math.floor(Math.random() * adjectives.length)]} ${nouns[Math.floor(Math.random() * nouns.length)]}`;
        }

        function generateFileId() {
            return 'file-' + Date.now().toString(36) + Math.random().toString(36).substring(2, 9);
        }

        function formatFileSize(bytes, decimals = 2) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }

        async function createPeerConnection(remotePeerId) {
            if (remotePeerId === localPeerId) return null;
            if (peerConnections[remotePeerId]) return peerConnections[remotePeerId];

            console.log(`Creating PeerConnection with ${remotePeerId}.`);
            const pc = new RTCPeerConnection(configuration);
            peerConnections[remotePeerId] = pc;

            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    sendSignalingMessage(remotePeerId, { candidate: event.candidate });
                }
            };

            pc.ondatachannel = (event) => {
                const dc = event.channel;
                console.log(`Data channel received from ${remotePeerId} (${peerNames[remotePeerId] || 'unknown'}). Label: ${dc.label}`);
                setupDataChannel(remotePeerId, dc);
            };

            pc.oniceconnectionstatechange = () => {
                const state = pc.iceConnectionState;
                console.log(`ICE connection state for ${remotePeerId} (${peerNames[remotePeerId] || 'unknown'}): ${state}`);
                if (['disconnected', 'failed', 'closed'].includes(state)) {
                    handleDisconnect(remotePeerId);
                } else if (state === 'connected') {
                    displayMessage('SYSTEM', `P2P connection successfully established: ${peerNames[remotePeerId] || remotePeerId}`, 'system-message');
                    updatePeersList();
                }
            };
            return pc;
        }

        function setupDataChannel(remotePeerId, dc) {
            dataChannels[remotePeerId] = dc;
            dc.binaryType = 'arraybuffer';

            dc.onopen = () => {
                console.log(`Data channel open with ${remotePeerId} (${peerNames[remotePeerId]}).`);

                // Immediately request peer's name when channel opens
                dc.send(JSON.stringify({
                    type: 'name-request'
                }));

                displayMessage('SYSTEM', `${peerNames[remotePeerId] || remotePeerId} joined the chat.`, 'system-message');
                updatePeersList();
            };

            dc.onmessage = (event) => {
                if (typeof event.data === 'string') {
                    try {
                        const msgData = JSON.parse(event.data);
                        const senderDisplayName = peerNames[remotePeerId] || remotePeerId;

                        switch (msgData.type) {
                            case 'chat':
                                displayMessage(senderDisplayName, msgData.text, 'their-message');
                                break;
                            case 'file-request':
                                handleFileRequest(remotePeerId, msgData);
                                break;
                            case 'file-accept':
                                handleFileAccept(remotePeerId, msgData);
                                break;
                            case 'file-reject':
                                handleFileReject(remotePeerId, msgData);
                                break;
                            case 'file-start':
                                if (fileTransfers[msgData.fileId] && fileTransfers[msgData.fileId].status === 'approved_to_receive' && fileTransfers[msgData.fileId].peerId === remotePeerId) {
                                    const transfer = fileTransfers[msgData.fileId];
                                    transfer.status = 'receiving';
                                    transfer.meta = msgData;
                                    transfer.chunks = [];
                                    transfer.receivedBytes = 0;
                                    updateTransferMessage(msgData.fileId, `Starting to receive file: <strong>${msgData.name}</strong> (${formatFileSize(msgData.size)}) from: ${senderDisplayName}.`, 0);
                                }
                                break;
                            case 'file-end':
                                handleFileEnd(remotePeerId, msgData);
                                break;
                            case 'keep-alive':
                                // Keep-alive message received - no action needed, just acknowledge receipt
                                console.log(`Keep-alive ping received from ${peerNames[remotePeerId] || remotePeerId}`);
                                break;
                            case 'name-request':
                                // Peer is requesting our name, send it
                                if (dataChannels[remotePeerId] && dataChannels[remotePeerId].readyState === 'open') {
                                    dataChannels[remotePeerId].send(JSON.stringify({
                                        type: 'name-response',
                                        name: myRandomName
                                    }));
                                }
                                break;
                            case 'name-response':
                                // Peer sent their name
                                if (msgData.name) {
                                    console.log(`Received name from peer ${remotePeerId}: ${msgData.name}`);
                                    peerNames[remotePeerId] = msgData.name;
                                    // Force update the peer list to show the correct name
                                    updatePeersList();
                                }
                                break;
                        }
                    } catch (e) {
                        console.error("Error processing message:", e);
                    }
                } else {
                    // Binary data - file chunk
                    handleFileChunk(remotePeerId, event.data);
                }
            };

            dc.onclose = () => {
                console.log(`Data channel closed with ${remotePeerId} (${peerNames[remotePeerId] || 'unknown'})`);
                handleDisconnect(remotePeerId);
            };

            dc.onerror = (error) => {
                console.error(`Data channel error with ${remotePeerId}:`, error);
            };

            // Request peer's name if we don't have it yet
            if (dc.readyState === 'open' && (!peerNames[remotePeerId] || peerNames[remotePeerId].startsWith('Connecting'))) {
                dc.send(JSON.stringify({
                    type: 'name-request'
                }));
            }

            // Setup keep-alive for mobile connections
            if (isMobileDevice()) {
                setupKeepAlive(remotePeerId);
            }
        }

        function setupKeepAlive(peerId) {
            // Clear any existing interval
            if (keepAliveIntervals[peerId]) {
                clearInterval(keepAliveIntervals[peerId]);
            }

            // Set new interval - send keep-alive every 30 seconds when no file operations are active
            keepAliveIntervals[peerId] = setInterval(() => {
                const dc = dataChannels[peerId];
                if (dc && dc.readyState === 'open' && !isFileOperationActive) {
                    try {
                        dc.send(JSON.stringify({
                            type: 'keep-alive',
                            timestamp: Date.now()
                        }));
                        console.log(`Sent keep-alive ping to ${peerNames[peerId] || peerId}`);
                    } catch (err) {
                        console.error(`Error sending keep-alive to ${peerId}:`, err);
                    }
                }
            }, 30000); // 30 seconds
        }

        function enhancedPeerDiscovery(peerId, deviceType) {
            // Reset connection attempts if this is a new discovery
            if (!connectionAttempts[peerId]) {
                connectionAttempts[peerId] = 0;
            }

            // Clear any existing timeout
            if (connectionTimeouts[peerId]) {
                clearTimeout(connectionTimeouts[peerId]);
            }

            // Attempt connection with exponential backoff
            const attemptConnection = async () => {
                connectionAttempts[peerId]++;

                if (connectionAttempts[peerId] > connectionRetryConfig.maxRetries) {
                    logPeerDiscovery('error', `Connection failed after ${connectionAttempts[peerId] - 1} attempts`, peerId);
                    return;
                }

                logPeerDiscovery('info', `Connection attempt ${connectionAttempts[peerId]}/${connectionRetryConfig.maxRetries}`, peerId);

                try {
                    const pc = await createPeerConnection(peerId);
                    if (!pc) return;

                    // Create data channel
                    const dc = pc.createDataChannel(`chat-${Date.now()}`);
                    setupDataChannel(peerId, dc);

                    // Create and send offer
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);

                    // Send offer with additional metadata
                    sendSignalingMessage(peerId, {
                        sdp: pc.localDescription,
                        name: myRandomName,
                        deviceType: isMobileDevice() ? 'mobile' : 'desktop',
                        attempt: connectionAttempts[peerId]
                    });

                } catch (err) {
                    logPeerDiscovery('error', `Error creating connection: ${err.message}`, peerId);

                    // Schedule retry with exponential backoff
                    const delay = Math.min(
                        connectionRetryConfig.baseDelay * Math.pow(connectionRetryConfig.backoffMultiplier, connectionAttempts[peerId] - 1),
                        connectionRetryConfig.maxDelay
                    );

                    connectionTimeouts[peerId] = setTimeout(attemptConnection, delay);
                }
            };

            // Start connection process
            attemptConnection();
        }

        async function handleOffer(peerId, sdp, peerName, deviceType, attempt) {
            try {
                peerNames[peerId] = peerName;

                const pc = await createPeerConnection(peerId);
                if (!pc) return;

                await pc.setRemoteDescription(new RTCSessionDescription(sdp));
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);

                sendSignalingMessage(peerId, {
                    sdp: pc.localDescription,
                    name: myRandomName,
                    deviceType: isMobileDevice() ? 'mobile' : 'desktop'
                });

                updatePeersList();

            } catch (err) {
                console.error(`Error handling offer from ${peerId}:`, err);
            }
        }

        async function handleAnswer(peerId, sdp) {
            try {
                const pc = peerConnections[peerId];
                if (pc) {
                    await pc.setRemoteDescription(new RTCSessionDescription(sdp));
                }
            } catch (err) {
                console.error(`Error handling answer from ${peerId}:`, err);
            }
        }

        async function handleCandidate(peerId, candidate) {
            try {
                const pc = peerConnections[peerId];
                if (pc) {
                    await pc.addIceCandidate(new RTCIceCandidate(candidate));
                }
            } catch (err) {
                console.error(`Error handling ICE candidate from ${peerId}:`, err);
            }
        }

        function handleDisconnect(peerId) {
            // Clean up connection resources
            if (dataChannels[peerId]) {
                if (dataChannels[peerId].readyState === 'open') {
                    dataChannels[peerId].close();
                }
                delete dataChannels[peerId];
            }

            if (peerConnections[peerId]) {
                peerConnections[peerId].close();
                delete peerConnections[peerId];
            }

            // Clean up keep-alive interval
            if (keepAliveIntervals[peerId]) {
                clearInterval(keepAliveIntervals[peerId]);
                delete keepAliveIntervals[peerId];
            }

            // Clean up connection attempts
            delete connectionAttempts[peerId];
            if (connectionTimeouts[peerId]) {
                clearTimeout(connectionTimeouts[peerId]);
                delete connectionTimeouts[peerId];
            }

            // Display disconnect message if we had a name (meaning connection was established)
            if (peerNames[peerId] && !peerNames[peerId].startsWith('Connecting')) {
                displayMessage('SYSTEM', `${peerNames[peerId]} disconnected.`, 'system-message');
            }

            // Keep the name for a while in case they reconnect
            setTimeout(() => {
                if (!peerConnections[peerId]) {
                    delete peerNames[peerId];
                }
            }, 60000); // Remove name after 1 minute if no reconnection

            updatePeersList();
        }

        function sendSignalingMessage(peerId, data) {
            if (ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    dest: peerId,
                    data: data
                }));
            }
        }

        function updatePeersList() {
            const connectedPeers = Object.keys(dataChannels).filter(peerId =>
                dataChannels[peerId] && dataChannels[peerId].readyState === 'open'
            );

            const connectingPeers = Object.keys(peerConnections).filter(peerId =>
                !dataChannels[peerId] || dataChannels[peerId].readyState !== 'open'
            );

            if (connectedPeers.length === 0 && connectingPeers.length === 0) {
                peersContainer.innerHTML = '<p>No peers available at the moment.</p>';
                recipientSelect.innerHTML = '';
                recipientSelect.classList.add('hidden');
                sendButton.classList.add('hidden');
                return;
            }

            let html = '<ul>';
            let selectHtml = '<option value="broadcast">Everyone</option>';

            // First show connected peers
            connectedPeers.forEach(peerId => {
                // Fix Bug 1: Use the actual peer name, not "Connecting ID"
                const peerName = peerNames[peerId] && !peerNames[peerId].startsWith('Connecting') ?
                    peerNames[peerId] :
                    `Peer (${peerId.substring(0, 6)})`;

                // Fix Bug 2: Add Send File button alongside Chat button
                html += `
                    <li class="peer">
                        <span>${peerName}</span>
                        <div>
                            <button onclick="selectPeer('${peerId}')">Chat</button>
                            <button onclick="selectFile('${peerId}')">Send File</button>
                        </div>
                    </li>
                `;
                selectHtml += `<option value="${peerId}">${peerName}</option>`;
            });

            // Then show connecting peers
            connectingPeers.forEach(peerId => {
                const peerName = peerNames[peerId] || `Unknown (${peerId.substring(0, 6)}...)`;
                html += `
                    <li class="peer">
                        <span>${peerName} (connecting...)</span>
                    </li>
                `;
            });

            html += '</ul>';
            peersContainer.innerHTML = html;
            recipientSelect.innerHTML = selectHtml;
        }

        function displayMessage(sender, content, className = '') {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${className}`;

            const senderSpan = document.createElement('span');
            senderSpan.className = 'sender';
            senderSpan.textContent = sender;

            const contentDiv = document.createElement('div');
            contentDiv.className = 'content';
            contentDiv.innerHTML = content;

            messageDiv.appendChild(senderSpan);
            messageDiv.appendChild(contentDiv);

            // Add copy button for non-system messages
            if (!className.includes('system-message')) {
                const copyBtn = document.createElement('button');
                copyBtn.className = 'copy-btn';
                copyBtn.textContent = 'Copy';
                copyBtn.onclick = function () {
                    navigator.clipboard.writeText(content)
                        .then(() => {
                            copyBtn.textContent = 'Copied!';
                            setTimeout(() => {
                                copyBtn.textContent = 'Copy';
                            }, 2000);
                        })
                        .catch(err => {
                            console.error('Failed to copy: ', err);
                        });
                };
                messageDiv.appendChild(copyBtn);
            }

            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;

            return messageDiv;
        }

        function createTransferMessage(fileId, content, className = '') {
            const messageDiv = displayMessage('SYSTEM', content, `file-transfer-message ${className}`);
            messageDiv.id = `transfer-${fileId}`;
            return messageDiv;
        }

        function updateTransferMessage(fileId, content, progress = null) {
            const messageDiv = document.getElementById(`transfer-${fileId}`);
            if (!messageDiv) return;

            const contentDiv = messageDiv.querySelector('.content');
            if (contentDiv) {
                contentDiv.innerHTML = content;
            }

            // Update or create progress bar
            if (progress !== null) {
                let progressBarContainer = messageDiv.querySelector('.progress-bar-container');

                if (!progressBarContainer) {
                    progressBarContainer = document.createElement('div');
                    progressBarContainer.className = 'progress-bar-container';

                    const progressBar = document.createElement('div');
                    progressBar.className = 'progress-bar';

                    progressBarContainer.appendChild(progressBar);
                    contentDiv.appendChild(progressBarContainer);
                }

                const progressBar = progressBarContainer.querySelector('.progress-bar');
                progressBar.style.width = `${progress}%`;
                progressBar.textContent = `${Math.round(progress)}%`;
            }

            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function addTransferActions(fileId, peerId, fileName) {
            const messageDiv = document.getElementById(`transfer-${fileId}`);
            if (!messageDiv) return;

            const contentDiv = messageDiv.querySelector('.content');
            if (!contentDiv) return;

            // Create actions container
            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'actions';

            // Accept button
            const acceptBtn = document.createElement('button');
            acceptBtn.textContent = 'Accept';
            acceptBtn.onclick = function () {
                acceptFile(fileId, peerId);
                actionsDiv.remove();
            };

            // Reject button
            const rejectBtn = document.createElement('button');
            rejectBtn.textContent = 'Reject';
            rejectBtn.onclick = function () {
                rejectFile(fileId, peerId);
                actionsDiv.remove();
            };

            actionsDiv.appendChild(acceptBtn);
            actionsDiv.appendChild(rejectBtn);
            contentDiv.appendChild(actionsDiv);
        }

        function handleFileRequest(peerId, msgData) {
            const fileId = msgData.fileId;
            const fileName = msgData.name;
            const fileSize = msgData.size;
            const senderName = peerNames[peerId] || peerId;

            fileTransfers[fileId] = {
                peerId: peerId,
                status: 'pending',
                name: fileName,
                size: fileSize
            };

            const message = `${senderName} wants to send you a file: <strong>${fileName}</strong> (${formatFileSize(fileSize)})`;
            createTransferMessage(fileId, message);

            // Auto-accept or show accept/reject buttons
            if (autoAcceptFilesToggle.checked) {
                acceptFile(fileId, peerId);
            } else {
                addTransferActions(fileId, peerId, fileName);
            }
        }

        function acceptFile(fileId, peerId) {
            if (!fileTransfers[fileId] || fileTransfers[fileId].status !== 'pending') return;

            fileTransfers[fileId].status = 'approved_to_receive';

            if (dataChannels[peerId] && dataChannels[peerId].readyState === 'open') {
                dataChannels[peerId].send(JSON.stringify({
                    type: 'file-accept',
                    fileId: fileId
                }));

                updateTransferMessage(fileId, `Waiting for file transfer to start...`);
            }
        }

        function rejectFile(fileId, peerId) {
            if (!fileTransfers[fileId]) return;

            fileTransfers[fileId].status = 'rejected';

            if (dataChannels[peerId] && dataChannels[peerId].readyState === 'open') {
                dataChannels[peerId].send(JSON.stringify({
                    type: 'file-reject',
                    fileId: fileId
                }));

                updateTransferMessage(fileId, `File transfer rejected.`);
            }
        }

        function handleFileAccept(peerId, msgData) {
            const fileId = msgData.fileId;

            if (!fileTransfers[fileId] || fileTransfers[fileId].status !== 'waiting_approval') return;

            fileTransfers[fileId].status = 'approved_to_send';
            updateTransferMessage(fileId, `${peerNames[peerId] || peerId} accepted the file transfer. Starting...`);

            // Start sending the file
            startFileSend(fileId, peerId);
        }

        function handleFileReject(peerId, msgData) {
            const fileId = msgData.fileId;

            if (!fileTransfers[fileId]) return;

            fileTransfers[fileId].status = 'rejected';
            updateTransferMessage(fileId, `${peerNames[peerId] || peerId} rejected the file transfer.`);

            // Clean up file resources
            if (fileTransfers[fileId].file) {
                URL.revokeObjectURL(fileTransfers[fileId].file);
            }
        }

        function startFileSend(fileId, peerId) {
            const transfer = fileTransfers[fileId];
            if (!transfer || !transfer.file || transfer.status !== 'approved_to_send') return;

            const file = transfer.file;
            const dc = dataChannels[peerId];

            if (!dc || dc.readyState !== 'open') {
                updateTransferMessage(fileId, `Error: Connection to peer lost.`);
                return;
            }

            // Send file metadata
            dc.send(JSON.stringify({
                type: 'file-start',
                fileId: fileId,
                name: file.name,
                size: file.size,
                contentType: file.type
            }));

            // Set up file reading and sending
            const chunkSize = CHUNK_SIZE;
            const reader = new FileReader();
            let offset = 0;

            transfer.status = 'sending';
            transfer.sentBytes = 0;
            transfer.startTime = Date.now();
            isFileOperationActive = true;

            const sendNextChunk = () => {
                if (transfer.status !== 'sending') {
                    isFileOperationActive = false;
                    return;
                }

                if (offset >= file.size) {
                    // File sending complete
                    dc.send(JSON.stringify({
                        type: 'file-end',
                        fileId: fileId
                    }));

                    const duration = (Date.now() - transfer.startTime) / 1000;
                    const speed = file.size / duration;

                    updateTransferMessage(
                        fileId,
                        `File <strong>${file.name}</strong> sent successfully! (${formatFileSize(file.size)} in ${duration.toFixed(1)}s, ${formatFileSize(speed)}/s)`,
                        100
                    );

                    transfer.status = 'completed';
                    URL.revokeObjectURL(file);
                    isFileOperationActive = false;
                    return;
                }

                // Check if we need to throttle sending due to buffered data
                if (dc.bufferedAmount > MAX_BUFFERED_AMOUNT_SEND_THRESHOLD) {
                    setTimeout(sendNextChunk, 100);
                    return;
                }

                const slice = file.slice(offset, offset + chunkSize);
                reader.readAsArrayBuffer(slice);
            };

            reader.onload = (e) => {
                if (transfer.status !== 'sending') return;

                const chunk = e.target.result;
                dc.send(chunk);

                offset += chunk.byteLength;
                transfer.sentBytes += chunk.byteLength;

                // Update progress
                const progress = Math.min(100, Math.round((transfer.sentBytes / file.size) * 100));
                updateTransferMessage(
                    fileId,
                    `Sending file: <strong>${file.name}</strong> to ${peerNames[peerId] || peerId}...`,
                    progress
                );

                // Schedule next chunk
                setTimeout(sendNextChunk, 0);
            };

            reader.onerror = () => {
                updateTransferMessage(fileId, `Error reading file: ${reader.error}`);
                transfer.status = 'error';
                isFileOperationActive = false;
            };

            // Start the sending process
            sendNextChunk();
        }

        function handleFileChunk(peerId, chunk) {
            // Find the active file transfer for this peer
            const fileId = Object.keys(fileTransfers).find(id =>
                fileTransfers[id].peerId === peerId &&
                fileTransfers[id].status === 'receiving'
            );

            if (!fileId || !fileTransfers[fileId]) return;

            const transfer = fileTransfers[fileId];

            // Store the chunk
            transfer.chunks.push(chunk);
            transfer.receivedBytes += chunk.byteLength;

            // Update progress
            const progress = Math.min(100, Math.round((transfer.receivedBytes / transfer.meta.size) * 100));
            updateTransferMessage(
                fileId,
                `Receiving file: <strong>${transfer.meta.name}</strong> from ${peerNames[peerId] || peerId}...`,
                progress
            );
        }

        function handleFileEnd(peerId, msgData) {
            const fileId = msgData.fileId;

            if (!fileTransfers[fileId] || fileTransfers[fileId].status !== 'receiving') return;

            const transfer = fileTransfers[fileId];

            // Combine all chunks into a single blob
            const blob = new Blob(transfer.chunks, { type: transfer.meta.contentType || 'application/octet-stream' });

            // Create download link
            const url = URL.createObjectURL(blob);
            const fileName = transfer.meta.name;

            // Create a download link element
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = fileName;
            downloadLink.textContent = `Download ${fileName}`;
            downloadLink.target = "_blank";

            // Add the link to the message
            updateTransferMessage(fileId, `File received successfully! `, 100);

            // Append the link to the message
            const messageDiv = document.getElementById(`transfer-${fileId}`);
            if (messageDiv) {
                const contentDiv = messageDiv.querySelector('.content');
                if (contentDiv) {
                    contentDiv.appendChild(downloadLink);
                }
            }

            // Automatically trigger download
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);

            // Clean up
            transfer.status = 'completed';
            delete transfer.chunks;
            isFileOperationActive = false;
        }

        // File selection and sending
        function selectFile(peerId) {
            const input = document.createElement('input');
            input.type = 'file';

            input.onchange = (e) => {
                if (!e.target.files.length) return;

                const file = e.target.files[0];
                const fileId = generateFileId();

                // Create file transfer record
                fileTransfers[fileId] = {
                    file: file,
                    peerId: peerId,
                    status: 'waiting_approval'
                };

                // Display message about file request
                createTransferMessage(
                    fileId,
                    `Requesting to send file: <strong>${file.name}</strong> (${formatFileSize(file.size)}) to ${peerNames[peerId] || peerId}...`
                );

                // Send file request to peer
                if (dataChannels[peerId] && dataChannels[peerId].readyState === 'open') {
                    dataChannels[peerId].send(JSON.stringify({
                        type: 'file-request',
                        fileId: fileId,
                        name: file.name,
                        size: file.size
                    }));
                } else {
                    updateTransferMessage(fileId, `Error: Connection to peer lost.`);
                }
            };

            input.click();
        }

        // UI Event Handlers
        window.selectPeer = function (peerId) {
            recipientSelect.value = peerId;
            recipientSelect.classList.remove('hidden');
            sendButton.classList.remove('hidden');
            messageInput.focus();
        };

        sendButton.addEventListener('click', () => {
            const text = messageInput.value.trim();
            if (!text) return;

            const selectedPeerId = recipientSelect.value;
            if (selectedPeerId === 'broadcast') {
                sendBroadcastMessage(text);
            } else {
                sendDirectMessage(selectedPeerId, text);
            }

            messageInput.value = '';
        });

        sendBroadcastButton.addEventListener('click', () => {
            const text = messageInput.value.trim();
            if (!text) return;

            sendBroadcastMessage(text);
            messageInput.value = '';
        });

        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                if (!recipientSelect.classList.contains('hidden')) {
                    sendButton.click();
                } else {
                    sendBroadcastButton.click();
                }
            }
        });

        function sendDirectMessage(peerId, text) {
            if (!dataChannels[peerId] || dataChannels[peerId].readyState !== 'open') {
                displayMessage('SYSTEM', `Cannot send message: Peer connection is not open.`, 'system-message');
                return;
            }

            dataChannels[peerId].send(JSON.stringify({
                type: 'chat',
                text: text
            }));

            displayMessage(`You → ${peerNames[peerId] || peerId}`, text, 'my-message');
        }

        function sendBroadcastMessage(text) {
            const connectedPeers = Object.keys(dataChannels).filter(id =>
                dataChannels[id] && dataChannels[id].readyState === 'open'
            );

            if (connectedPeers.length === 0) {
                displayMessage('SYSTEM', `Cannot send message: No connected peers.`, 'system-message');
                return;
            }

            connectedPeers.forEach(peerId => {
                dataChannels[peerId].send(JSON.stringify({
                    type: 'chat',
                    text: text
                }));
            });

            displayMessage(`You → Everyone`, text, 'my-message');
        }

        // Add file sharing to peer context menu
        document.addEventListener('click', function (e) {
            if (e.target && e.target.tagName === 'BUTTON' && e.target.textContent === 'Chat') {
                const peerItem = e.target.closest('.peer');
                if (peerItem) {
                    const peerSpan = peerItem.querySelector('span');
                    const peerName = peerSpan.textContent;
                    const peerId = e.target.onclick.toString().match(/'([^']+)'/)[1];

                    // Add file button if it doesn't exist
                    if (!peerItem.querySelector('.file-btn')) {
                        const fileBtn = document.createElement('button');
                        fileBtn.className = 'file-btn';
                        fileBtn.textContent = 'Send File';
                        fileBtn.onclick = function () {
                            selectFile(peerId);
                        };
                        peerItem.appendChild(fileBtn);
                    }
                }
            }
        });

        // Enhanced mobile device detection
        if (isMobileDevice()) {
            document.body.classList.add('mobile-device');
            console.log('Mobile device detected, enabling optimizations');
        }
    </script>
</body>

</html>